#!/usr/bin/python3
# -*- coding: utf-8 -*-
# key-mapper - GUI for device specific keyboard mappings
# Copyright (C) 2020 sezanzeb <proxima@hip70890b.de>
#
# This file is part of key-mapper.
#
# key-mapper is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# key-mapper is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with key-mapper.  If not, see <https://www.gnu.org/licenses/>.


"""User Interface."""


import sys
from argparse import ArgumentParser

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GLib', '2.0')
from gi.repository import Gtk, Gdk

from keymapper.data import get_data_path
from keymapper.X import create_setxkbmap_config, apply_preset, \
    create_preset, get_mappings
from keymapper.presets import get_presets, find_newest_preset, \
    delete_preset, rename_preset
from keymapper.logger import logger, update_verbosity, log_info
from keymapper.linux import get_devices


window = None


# TODO check for sudo rights


class SingleKeyMapping:
    """A single, configurable key mapping."""
    def __init__(self, delete_callback, key_code=None, character=None):
        """Construct a row and add it to the list in the GUI."""
        self.widget = None
        self.delete_callback = delete_callback
        self.put_together(key_code, character)

    def get_widget(self):
        """Return the widget that wraps all the widgets of the row."""
        return self.widget

    def get_code(self):
        return int(self.key_code.get_text())

    def get_character(self):
        return self.character.get_text()

    def put_together(self, key_code, character):
        """Create all GTK widgets."""
        delete_button = Gtk.EventBox()
        delete_button.add(Gtk.Image.new_from_icon_name(
            'window-close', Gtk.IconSize.BUTTON
        ))
        delete_button.connect(
            'button-press-event',
            self.on_delete_button_clicked
        )
        delete_button.set_margin_start(5)
        delete_button.set_margin_end(5)

        key_code_input = Gtk.Entry()
        key_code_input.set_alignment(0.5)
        key_code_input.set_width_chars(4)
        key_code_input.set_has_frame(False)
        key_code_input.set_input_purpose(Gtk.InputPurpose.NUMBER)
        if key_code is not None:
            key_code_input.set_text(key_code)

        character_input = Gtk.Entry()
        character_input.set_alignment(0.5)
        character_input.set_width_chars(4)
        character_input.set_has_frame(False)
        if character is not None:
            character_input.set_text(character)

        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        row.set_homogeneous(True)
        row.pack_start(key_code_input, expand=True, fill=True, padding=0)
        row.pack_start(character_input, expand=True, fill=True, padding=0)
        row.pack_start(delete_button, expand=True, fill=False, padding=0)

        row.show_all()
        # in order to get this object when iterating over the listbox
        row.logic = self

        self.widget = row
        self.character_input = character_input
        self.key_code = key_code_input

    def on_delete_button_clicked(self, *args):
        """Destroy the row and remove it from the config."""
        self.delete_callback(self)


class Window:
    """User Interface."""
    def __init__(self):
        self.selected_device = None
        self.selected_preset = None
        self.mappings = []

        gladefile = get_data_path('key-mapper.glade')
        builder = Gtk.Builder()
        builder.add_from_file(gladefile)
        builder.connect_signals(self)
        self.builder = builder

        window = self.get('window')
        window.show()
        self.window = window

        self.populate_devices()

        self.select_newest_preset()

        css_provider = Gtk.CssProvider()
        css_provider.load_from_path(get_data_path('style.css'))
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

    def get(self, name):
        """Get a widget from the window"""
        return self.builder.get_object(name)

    def on_close(self, *_):
        """Safely close the application."""
        Gtk.main_quit()

    def select_newest_preset(self):
        """Find and select the newest preset."""
        device, preset = find_newest_preset()
        if device is not None:
            self.get('device_selection').set_active_id(device)
        if preset is not None:
            self.get('device_selection').set_active_id(preset)

    def populate_devices(self):
        """Make the devices selectable."""
        devices = get_devices()
        device_selection = self.get('device_selection')
        for device in devices:
            device_selection.append(device, device)

    def populate_presets(self):
        """Show the available presets for the selected device."""
        device = self.selected_device
        presets = get_presets(device)
        self.get('preset_name_input').set_text('')
        if len(presets) == 0:
            presets = [create_preset(device)]
        else:
            logger.debug('Presets for "%s": %s', device, ', '.join(presets))
        preset_selection = self.get('preset_selection')

        preset_selection.handler_block_by_func(self.on_select_preset)
        # otherwise the handler is called with None for each removed preset
        preset_selection.remove_all()
        preset_selection.handler_unblock_by_func(self.on_select_preset)

        for preset in presets:
            preset_selection.append(preset, preset)
        # and select the newest one (on the top)
        preset_selection.set_active(0)

    def clear_mapping_table(self):
        """Remove all rows from the mappings table."""
        key_list = self.get('key_list')
        key_list.forall(key_list.remove)

    def update_mappings(self):
        """Construct the mapping from the inputs without saving or applying."""
        key_list = self.get('key_list')
        mappings = []

        def read_mapping(row):
            box = row.get_children()[0]
            columns = box.get_children()
            # TODO test if columns[0] is a number
            #   and if one of them is empty
            mappings.append((
                int(columns[0].get_text()),
                columns[1].get_text()
            ))

        key_list.forall(read_mapping)
        logger.debug('Constructed mappings: %s', mappings)
        self.mappings = mappings

    def on_save_preset_clicked(self, button):
        """Save changes to a preset to the file system."""
        new_name = self.get('preset_name_input').get_text()
        if new_name != '' and new_name != self.selected_preset:
            rename_preset(self.selected_device, self.selected_preset, new_name)
            self.populate_presets()

        self.update_mappings()
        self.update_config()

    def on_delete_preset_clicked(self, button):
        """Delete a preset from the file system."""
        delete_preset(self.selected_device, self.selected_preset)
        self.populate_presets()

    def on_apply_preset_clicked(self, button):
        """Apply a preset without saving changes."""
        self.update_mappings()
        logger.debug(
            'Applying preset "%s" for "%s"',
            self.selected_preset,
            self.selected_device
        )
        apply_preset(self.selected_device, self.selected_preset)

    def on_select_device(self, dropdown):
        """List all presets, create one if none exist yet."""
        device = dropdown.get_active_text()

        logger.debug('Selecting device "%s"', device)

        self.selected_device = device
        self.selected_preset = None
        self.mappings = []

        self.populate_presets()

    def on_create_preset_clicked(self, button):
        """Create a new preset and select it."""
        new_preset = create_preset(self.selected_device)
        self.get('preset_selection').append(new_preset, new_preset)
        self.get('preset_selection').set_active_id(new_preset)
        self.update_config()

    def on_select_preset(self, dropdown):
        """Show the mappings of the preset."""
        self.clear_mapping_table()

        preset = dropdown.get_active_text()
        logger.debug('Selecting preset "%s"', preset)

        self.selected_preset = preset
        mappings = get_mappings(
            self.selected_device,
            self.selected_preset
        )

        key_list = self.get('key_list')
        for mapping in mappings:
            mapping = SingleKeyMapping(
                self.on_row_removed,
                mapping[0], mapping[1]
            )
            key_list.insert(mapping.get_widget(), -1)

        self.mappings = mappings

        self.add_empty()

    def add_empty(self):
        empty = SingleKeyMapping(self.on_row_removed)
        key_list = self.get('key_list')
        key_list.insert(empty.get_widget(), -1)

    def on_row_removed(self, mapping):
        """Stuff to do when a row was removed

        Parameters
        ----------
        mapping : SingleKeyMapping
        """
        key_list = self.get('key_list')
        # https://stackoverflow.com/a/30329591/4417769
        key_list.remove(mapping.get_widget().get_parent())
        # shrink the window down as much as possible, otherwise it
        # will increase with each added mapping but won't go back when they
        # are removed.
        window = self.get('window')
        window.resize(window.get_size()[0], 1)

    def update_config(self):
        """Write changes to disk"""
        if self.selected_device is None or self.selected_preset is None:
            return

        logger.info(
            'Updating configs for "%s", "%s"',
            self.selected_device,
            self.selected_preset
        )

        create_setxkbmap_config(
            self.selected_device,
            self.selected_preset,
            self.mappings
        )


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument(
        '-d', '--debug', action='store_true', dest='debug',
        help='Displays additional debug information',
        default=False
    )

    options = parser.parse_args(sys.argv[1:])
    update_verbosity(options.debug)
    log_info()

    window = Window()
    Gtk.main()
